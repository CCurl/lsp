This is a simple compiler, disassembler and vm-emulator, mostly for learning.<br/>
It also includes a heap-based memory management system (not currently).<br/>
It supports a C-like syntax.<br/>
It's initial purpose was to be a pedagogical tool for learning about compilers.<br/>
It has matured into a serious attempt at a minimal and simply full-fledged compiler.<br/>
The compiler does a minimal amount of error checking to help highlight the structure of the compiler.<br/>
<br/>
Note: I am interested in learning how compilers work, and I came across Marc Feeley's Tiny-C.<br/>
I found it here: http://www.iro.umontreal.ca/~felipe/IFT2030-Automne2002/Complements/tinyc.c<br/>
Seeing the copyright, I emailed Mark and asked him if I could use it, and he said<br/>
that it was under a MIT license and I could do what I wanted with it.<br/>
This work is based on Marc's tinyc.c effort.<br/>
<br/>
The idea is to build on tiny-c to generate runnable, program in byte-code.<br/>
That program (tc.out) can be input into gen-lin to create a native executable for Linux.<br/>
<br/>
The grammar of language in EBNF is:

```
  <program>   ::= <defs>
  <defs>      ::= <def> | <def> <def>
  <def>       ::= <func_def> | <int-def> | <byte-def>
  <func-def>  ::= "void" <id> "()" "{" <statement> "}" |
  <int-def>   ::= "int"  <id> ";" | "int" <id>  "[" <int> "]" ";"
  <byte-def>  ::= "byte" <id> ";" | "byte" <id> "[" <int> "]" ";"
  <statement> ::= "if" <paren_expr> <statement> |
                  "if" <paren_expr> <statement> "else" <statement> |
                  "while" <paren_expr> <statement> |
                  "do" <statement> "while" <paren_expr> ";" |
                  "{" <statement> "}" |
                  <func-call> ";" |
                  <expr> ";" |
                  <id> "=" <expr> ";" |
                  <id> "[" <expr> "]" "=" <expr> ";" | (future)
                  "//" |
                  ";"
  <paren_expr> ::= "(" <expr> ")"
  <expr>       ::= <math> | <math> <test-op> <math>
  <test-op>    ::= one of (< = > != || &&)
  <math>       ::= <term> | <math> <math_op> <term>
  <math-op>    ::= one of (+ - * / & | ^)
  <term>       ::= <id> | <int> | <string> | <paren_expr>
  <id>         ::= <alpha><alpha-numeric>*
  <int>        ::= [0-9]*
  <string>     ::= '"' <chars> '"'
  <func-call>  ::= <id> "(" ")"
 ```

It is broken into multiple parts
- each part is implemented in a single file.

tc.c: the tiny-c compiler
- This takes a .tc file as the only argument.
- If no argument is given, it reads the source from stdin.
- The output is written to file 'tc.out'.
- tc.out is (will be) an executable program.
- It also generates file 'tc.sym', a listing of the symbols defined.

hex-dump.c: A little program to dump a file's contents in hex.

vm.c: an x86/Linux emulator
- This is VM that emulates an extremely stripped down Linux/x86 system.
- It generates file 'vm.lst', a disassembly listing of the program.

Debugging:
- the vm generates 'vm.lst' before it runs so it is easy to see what it thinks the program is.
- using tc.sym and vm.lst together provide a pretty good picture of what the generated program.

Running:
```
make tc
make vm-stk
make test
make bm
```

TODO:
- [i] Create a simple emulator that can run a subset of x86 machine code.
- [i] Update tc.c to generate x86 machine code for the above emulator.
- [ ] Generate an x86 executable program.
- [ ] Optimize the code generated by tc.c.

Linux - x86 system calls
- https://rbmj.github.io/iwg/exploit/x86_table.html
- https://www.chromium.org/chromium-os/developer-library/reference/linux-constants/syscalls/#x86-32-bit
- http://ref.x86asm.net/coder32-abc.html#modrm_byte_32

Online Assembler -
- https://yozan233.github.io/Online-Assembler-Disassembler/

Linux - execution start address: 0x08048000

sys_brk (syscall #45)
- Put the requested new end address into EBX
- Returns the new end address in EAX
- When EBX=0, it returns the current end

To allocate 256 bytes memory:
    ; Get the current program break
    mov eax, 45         ; syscall number for sys_brk
    xor ebx, ebx        ; pass NULL to get current break
    int 0x80            ; call kernel

    ; Store the current break in ebx
    mov ebx, eax        ; ebx now holds the current program break

    ; Set the new program break
    mov eax, 45         ; syscall number for sys_brk
    add ebx, 256        ; set the new break address
    int 0x80            ; call kernel

Machine code
-------------

b8 11 22 33 44 - mov eax, 0x44332211
bb 55 66 77 88 - mov ebx, 0x88776655
b9 55 66 77 88 - mov ecx, 0x88776655
ba 55 66 77 88 - mov edx, 0x88776655

50 - push eax
53 - push ebx
51 - push ecx
52 - push edx

58 - pop eax
5b - pop ebx
59 - pop ecx
5a - pop edx

68 78 56 34 12             push 0x12345678
FF 35 78 56 34 12          push [0x12345678]

31 c0 - xor eax, eax
31 db - xor ebx, ebx
31 c9 - xor ecx, ecx
31 d2 - xor edx, edx

cd 80 -  int 0x80

8d 04 xx xx xx xx - lea eax, <addr>
8d 0d xx xx xx xx - lea ecx, <addr>

39 c3 - cmp eax, ebx

c3 - ret

  push:
0x10006:      89 D9                    mov ecx, ebx
0x10002:      89 C3                    mov ebx, eax

    pop:
0x10000:      89 D8                    mov eax, ebx
0x10004:      89 CB                    mov ebx, ecx

   zz:
0x10000:      31 D2                    xor edx, edx
0x10002:      39 C3                    cmp ebx, eax
0x10004:      74/75 01                 jz/jnz FALSE
0x10006:      42                       inc edx
   FALSE:
0x10007:      89 D0                    mov eax, edx
0x10009:      89 CB                    mov ebx, ecx

; Calling
   test:
0x12345:      29 D8                    sub eax, ebx
0x12347:      F7 D0                    not eax
0x12349:      C3                       ret
0x1234a:      8D 15 45 23 01 00        lea edx, [0x00012345]
0x12350:      8D 15 45 23 01 00        lea edx, [test]
0x12356:      FF D2                    call edx
0x12358:      C3                       ret

0x1000f:      93                       xchg eax, ebx
0x10010:      91                       xchg eax, ecx
0x10011:      87 CB                    xchg ebx, ecx
0x10013:      21 D8                    and eax, ebx
0x10015:      09 D8                    or  eax, ebx
0x10017:      31 D8                    xor eax, ebx
0x10019:      F7 EB                    imul ebx
0x1001b:      F7 FB                    idiv ebx
0x1001d:      C3                       ret

0x10000:      29 D8                    sub eax, ebx
0x10002:      F7 D0                    not eax
0x10004:      90                       nop
0x10013:      C3                       ret



0x10000:      55                 push ebp
0x10001:      89 E5              mov ebp, esp
0x10003:      89 EC              mov esp, ebp
0x10005:      5B                 pop ebx